import io from 'socket.io-client';
import CCC from './vendor.js';


const API_ENDPOINT = 'https://www.cryptocompare.com/api/data/';
const STREAMING_ENDPOINT = 'wss://streamer.cryptocompare.com';
const QUOTE_TYPE = CCC.STATIC.TYPE.CURRENTAGG;
const COIN_ID_KEY = 'cryptoCompare.coindIds';

let ws,
	coinIds = window.localStorage[COIN_ID_KEY],
	initialized = false,
	subscriptions = {};



function apiInit() {
	//
	// Fetch general info for all coins
	//
	if(coinIds) {
		coinIds = JSON.parse(coinIds);
	}
	else {
		// Not present in localStorage, fetch
		fetch(API_ENDPOINT + 'coinlist/'/*, {'mode': 'no-cors'}*/)
			.then(function(response) {
				// Map symbol to CryptoCompare internal ID
				Object.keys(response.Data).forEach(symbol => coinIds[symbol] = response.Data[symbol].Id);
				window.localStorage[COIN_ID_KEY] = JSON.stringify(coinIds);
			})
			.catch(function(err) {
				throw Error('api.js -- failed to load coin infos: ' + err);
			});
	}

	//
	// Init websocket
	//
	ws = io(STREAMING_ENDPOINT);

	ws.on('connect', function(){
		console.log('Connected!')
	});

	ws.on('event', function(data){
		console.log('Received event:');
		console.dir(data);
	});

	ws.on('disconnect', function(){
		console.log('Disconnected :(');
	});

	initialized = true;
}


function apiSubscribe(exchange, symbol, market, callback) {
	
	if(!initialized) {
		throw new Error('api.js -- you must call apiInit before adding subscriptions');
	}

	// If we're asking for aggregate data, override the exchange with the special
	// one that the API authors provide for that quote type
	QUOTE_TYPE === CCC.STATIC.TYPE.CURRENTAGG && (exchange = 'CCCAGG');
	QUOTE_TYPE === CCC.STATIC.TYPE.CURRENTAGG && (market = 'USD');

	let subKey = [
		QUOTE_TYPE,
		exchange,
		symbol,
		market
	].join('~');

	console.log('Adding coin subscription: ' + subKey);

	// Store reference to subscription-specific callback
	subscriptions[subKey] = callback;

	ws.emit('SubAdd', {
		subs: Object.keys(subscriptions)
	});

}


function apiFinalize() {
	// Listen for data
	ws.on('m', data => {
		// Decode message using crypto compare's util function
		if (data.substring(0, data.indexOf("~")) === QUOTE_TYPE) {
			// Extract subscription signature from data
			let subKey = CCC.CURRENT.getKeyFromStreamerData(data);
			// Call subscription-specific callback w/ update
			subscriptions[subKey](CCC.CURRENT.unpack(data));
		}
	});
}


export { apiInit, apiSubscribe, apiFinalize };